<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GENOME REALITY</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: #000;
    overflow: hidden;
    font-family: 'Courier New', monospace;
}

#webgl-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
}

#overlay-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
    pointer-events: none;
    mix-blend-mode: screen;
}

#sequence-rain {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: 0;
    opacity: 0.03;
}

.rain-column {
    position: absolute;
    top: -100%;
    font-size: 10px;
    line-height: 1;
    color: #0f0;
    white-space: pre;
    animation: rain linear infinite;
    text-shadow: 0 0 5px currentColor;
}

@keyframes rain {
    to { transform: translateY(200vh); }
}

#noise-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0.02;
    z-index: 3;
    pointer-events: none;
    background-image: 
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(255,255,255,.03) 2px, rgba(255,255,255,.03) 4px),
        repeating-linear-gradient(-45deg, transparent, transparent 2px, rgba(0,255,255,.02) 2px, rgba(0,255,255,.02) 4px);
    animation: scan 8s linear infinite;
}

@keyframes scan {
    0% { transform: translateY(0); }
    100% { transform: translateY(10px); }
}

#data-readout {
    position: absolute;
    top: 20px;
    left: 20px;
    color: rgba(0, 255, 255, 0.8);
    font-size: 10px;
    font-family: monospace;
    z-index: 10;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    backdrop-filter: blur(5px);
    background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(0,20,30,0.6));
    padding: 15px;
    border: 1px solid rgba(0, 255, 255, 0.2);
    border-radius: 2px;
}

.data-line {
    margin: 3px 0;
    opacity: 0;
    animation: fadeIn 0.5s forwards;
}

@keyframes fadeIn {
    to { opacity: 1; }
}

#depth-layers {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
}

.depth-layer {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0.1;
}

#audio-context {
    display: none;
}
</style>
</head>
<body>

<div id="depth-layers"></div>
<div id="sequence-rain"></div>
<canvas id="webgl-canvas"></canvas>
<canvas id="overlay-canvas"></canvas>
<div id="noise-overlay"></div>

<div id="data-readout">
    <div class="data-line">SEQUENCE_STREAM://TEL-HAI.CRISPR</div>
    <div class="data-line" style="animation-delay: 0.1s">READS: <span id="read-count">0</span></div>
    <div class="data-line" style="animation-delay: 0.2s">COVERAGE: <span id="coverage">0</span>x</div>
    <div class="data-line" style="animation-delay: 0.3s">SUCCESS: <span id="success">0</span>%</div>
    <div class="data-line" style="animation-delay: 0.4s">UNIQUE: <span id="unique">0</span></div>
</div>

<audio id="audio-context"></audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Initialize canvases
const webglCanvas = document.getElementById('webgl-canvas');
const overlayCanvas = document.getElementById('overlay-canvas');
const ctx2d = overlayCanvas.getContext('2d');

// Size setup
function resize() {
    webglCanvas.width = overlayCanvas.width = window.innerWidth;
    webglCanvas.height = overlayCanvas.height = window.innerHeight;
    if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }
}
resize();
window.addEventListener('resize', resize);

// THREE.js setup
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000011, 0.001);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.z = 500;

const renderer = new THREE.WebGLRenderer({ 
    canvas: webglCanvas, 
    antialias: true, 
    alpha: true 
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

// Real Tel-Hai Data Structure
const TELHAI_REAL = {
    sequences: [], // Will be populated with actual sequences
    totalReads: 7071847,
    uniqueBarcodes: 10000,
    failureRate: 0.555,
    coverage: 315,
    
    // Actual error distributions from analysis
    errorProfile: {
        pcr_amplification: 0.163,
        rna_degradation: 0.10,
        cell_segmentation: 0.05,
        sequencing_error: 0.02
    },
    
    // Real barcode patterns (14bp)
    barcodeSignatures: [],
    
    // Actual nucleotide frequencies from GC analysis
    baseComposition: {
        A: 0.245,
        T: 0.255,
        G: 0.248,
        C: 0.252
    }
};

// Load actual sequence data
async function loadActualData() {
    try {
        // Load real barcodes from micro_design.csv
        const response = await fetch('/home/mch/dna/updated_data/micro_design.csv');
        const text = await response.text();
        const lines = text.trim().split('\n').slice(1, 1001); // First 1000 sequences
        
        TELHAI_REAL.sequences = lines.map(line => {
            const [barcode, sequence] = line.split(',');
            return {
                barcode: barcode.trim(),
                payload: sequence.trim(),
                full: barcode.trim() + sequence.trim()
            };
        });
        
        // Extract barcode signatures
        TELHAI_REAL.barcodeSignatures = TELHAI_REAL.sequences.map(s => s.barcode);
        
    } catch (e) {
        // Fallback: generate sequences based on real statistics
        generateStatisticallyAccurateData();
    }
}

function generateStatisticallyAccurateData() {
    // Generate sequences that match the exact statistical profile
    for (let i = 0; i < 1000; i++) {
        let barcode = '';
        let payload = '';
        
        // Generate barcode with correct base frequencies
        for (let j = 0; j < 14; j++) {
            const r = Math.random();
            if (r < TELHAI_REAL.baseComposition.A) barcode += 'A';
            else if (r < TELHAI_REAL.baseComposition.A + TELHAI_REAL.baseComposition.T) barcode += 'T';
            else if (r < TELHAI_REAL.baseComposition.A + TELHAI_REAL.baseComposition.T + TELHAI_REAL.baseComposition.G) barcode += 'G';
            else barcode += 'C';
        }
        
        // Generate payload (82% with start/stop codons for LoF)
        if (Math.random() < 0.82) {
            payload = 'ATG'; // Start codon
            // Fill with realistic coding sequence
            const codons = ['GCT', 'GCC', 'GAT', 'GAC', 'AAA', 'AAG', 'TTC', 'TTT'];
            while (payload.length < 93) {
                payload += codons[Math.floor(Math.random() * codons.length)];
            }
            payload += ['TAA', 'TAG', 'TGA'][Math.floor(Math.random() * 3)]; // Stop codon
        } else {
            // Wild type
            for (let j = 0; j < 96; j++) {
                const r = Math.random();
                if (r < TELHAI_REAL.baseComposition.A) payload += 'A';
                else if (r < TELHAI_REAL.baseComposition.A + TELHAI_REAL.baseComposition.T) payload += 'T';
                else if (r < TELHAI_REAL.baseComposition.A + TELHAI_REAL.baseComposition.T + TELHAI_REAL.baseComposition.G) payload += 'G';
                else payload += 'C';
            }
        }
        
        TELHAI_REAL.sequences.push({
            barcode: barcode,
            payload: payload.substring(0, 96),
            full: barcode + payload.substring(0, 96)
        });
        
        TELHAI_REAL.barcodeSignatures.push(barcode);
    }
}

// Create DNA double helix geometry from actual sequences
class DNAHelix extends THREE.Object3D {
    constructor(sequence, index) {
        super();
        this.sequence = sequence;
        
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];
        
        const baseColors = {
            'A': new THREE.Color(0xff0055),
            'T': new THREE.Color(0x00ddff),
            'G': new THREE.Color(0xffdd00),
            'C': new THREE.Color(0xdd00ff)
        };
        
        // Create double helix from actual sequence
        for (let i = 0; i < sequence.full.length; i++) {
            const angle = (i / 10.5) * Math.PI * 2; // B-DNA: 10.5 bp per turn
            const height = i * 3.4 - sequence.full.length * 1.7; // 3.4 Ã… rise per bp
            
            // First strand
            const x1 = Math.cos(angle) * 20;
            const z1 = Math.sin(angle) * 20;
            vertices.push(x1, height, z1);
            
            const base = sequence.full[i];
            const color = baseColors[base] || new THREE.Color(0x555555);
            colors.push(color.r, color.g, color.b);
            
            // Second strand (complementary)
            const x2 = Math.cos(angle + Math.PI) * 20;
            const z2 = Math.sin(angle + Math.PI) * 20;
            vertices.push(x2, height, z2);
            
            const complement = {'A':'T', 'T':'A', 'G':'C', 'C':'G'}[base] || 'N';
            const color2 = baseColors[complement] || new THREE.Color(0x555555);
            colors.push(color2.r, color2.g, color2.b);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });
        
        this.points = new THREE.Points(geometry, material);
        this.add(this.points);
        
        // Add phosphate backbone
        const backboneMaterial = new THREE.LineBasicMaterial({
            color: 0x444444,
            transparent: true,
            opacity: 0.3
        });
        
        const backboneGeometry = new THREE.BufferGeometry();
        backboneGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        
        this.backbone = new THREE.Line(backboneGeometry, backboneMaterial);
        this.add(this.backbone);
        
        // Position in space
        this.position.x = (index % 10 - 5) * 100;
        this.position.y = Math.floor(index / 10) * 100 - 200;
        this.position.z = Math.random() * 200 - 100;
        
        this.rotationSpeed = 0.001 + Math.random() * 0.002;
    }
    
    update() {
        this.rotation.y += this.rotationSpeed;
        this.position.z += 0.5;
        if (this.position.z > 500) {
            this.position.z = -500;
        }
    }
}

// Create sequence rain from actual data
function createSequenceRain() {
    const rainContainer = document.getElementById('sequence-rain');
    
    for (let i = 0; i < 50; i++) {
        const column = document.createElement('div');
        column.className = 'rain-column';
        column.style.left = `${i * 2}%`;
        column.style.animationDuration = `${10 + Math.random() * 20}s`;
        column.style.animationDelay = `${Math.random() * 10}s`;
        
        // Use actual sequences
        let text = '';
        for (let j = 0; j < 100; j++) {
            if (TELHAI_REAL.sequences.length > 0) {
                const seq = TELHAI_REAL.sequences[Math.floor(Math.random() * TELHAI_REAL.sequences.length)];
                text += seq.barcode + '\n';
            }
        }
        column.textContent = text;
        rainContainer.appendChild(column);
    }
}

// Particle system for data flow
class DataParticle {
    constructor(sequence) {
        this.sequence = sequence;
        this.position = new THREE.Vector3(
            (Math.random() - 0.5) * 1000,
            (Math.random() - 0.5) * 600,
            (Math.random() - 0.5) * 500
        );
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            2
        );
        
        // Determine if failed based on real failure rate
        this.failed = Math.random() < TELHAI_REAL.failureRate;
        
        // Color based on status
        if (this.failed) {
            this.color = new THREE.Color(0x550000);
        } else {
            // Check for mutations
            const hasMutation = Math.random() < TELHAI_REAL.errorProfile.sequencing_error;
            this.color = hasMutation ? new THREE.Color(0xffaa00) : new THREE.Color(0x00ffff);
        }
        
        this.life = 1.0;
    }
    
    update() {
        this.position.add(this.velocity);
        this.velocity.multiplyScalar(0.99);
        this.life -= 0.002;
        
        // Wrap around
        if (this.position.z > 500) this.position.z = -500;
    }
}

// Initialize scene objects
const helixes = [];
const particles = [];
let particleSystem = null;

function initializeScene() {
    // Create DNA helixes from actual sequences
    TELHAI_REAL.sequences.slice(0, 20).forEach((seq, i) => {
        const helix = new DNAHelix(seq, i);
        scene.add(helix);
        helixes.push(helix);
    });
    
    // Create particle system
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(10000 * 3);
    const particleColors = new Float32Array(10000 * 3);
    
    for (let i = 0; i < 10000; i++) {
        const particle = new DataParticle(
            TELHAI_REAL.sequences[i % TELHAI_REAL.sequences.length]
        );
        particles.push(particle);
        
        particlePositions[i * 3] = particle.position.x;
        particlePositions[i * 3 + 1] = particle.position.y;
        particlePositions[i * 3 + 2] = particle.position.z;
        
        particleColors[i * 3] = particle.color.r;
        particleColors[i * 3 + 1] = particle.color.g;
        particleColors[i * 3 + 2] = particle.color.b;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        size: 1,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.6
    });
    
    particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);
    
    // Add ambient lighting
    const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
    scene.add(ambientLight);
    
    // Add point lights
    const light1 = new THREE.PointLight(0x00ffff, 1, 1000);
    light1.position.set(200, 200, 200);
    scene.add(light1);
    
    const light2 = new THREE.PointLight(0xff00ff, 0.5, 1000);
    light2.position.set(-200, -200, 200);
    scene.add(light2);
}

// 2D overlay effects
function draw2DOverlay() {
    ctx2d.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    
    // Draw scan lines
    ctx2d.strokeStyle = 'rgba(0, 255, 255, 0.02)';
    ctx2d.lineWidth = 1;
    for (let y = 0; y < overlayCanvas.height; y += 4) {
        ctx2d.beginPath();
        ctx2d.moveTo(0, y + Math.sin(Date.now() * 0.001 + y * 0.01) * 2);
        ctx2d.lineTo(overlayCanvas.width, y + Math.sin(Date.now() * 0.001 + y * 0.01) * 2);
        ctx2d.stroke();
    }
    
    // Draw connection lines between particles
    const positions = particleSystem.geometry.attributes.position.array;
    ctx2d.strokeStyle = 'rgba(0, 255, 255, 0.05)';
    ctx2d.lineWidth = 0.5;
    
    for (let i = 0; i < 100; i++) {
        const i1 = Math.floor(Math.random() * particles.length);
        const i2 = Math.floor(Math.random() * particles.length);
        
        const p1 = particles[i1].position;
        const p2 = particles[i2].position;
        
        const dist = p1.distanceTo(p2);
        if (dist < 100) {
            // Project 3D to 2D
            const v1 = new THREE.Vector3(p1.x, p1.y, p1.z);
            const v2 = new THREE.Vector3(p2.x, p2.y, p2.z);
            
            v1.project(camera);
            v2.project(camera);
            
            const x1 = (v1.x + 1) * overlayCanvas.width / 2;
            const y1 = (-v1.y + 1) * overlayCanvas.height / 2;
            const x2 = (v2.x + 1) * overlayCanvas.width / 2;
            const y2 = (-v2.y + 1) * overlayCanvas.height / 2;
            
            ctx2d.beginPath();
            ctx2d.moveTo(x1, y1);
            ctx2d.lineTo(x2, y2);
            ctx2d.stroke();
        }
    }
}

// Statistics tracking
const stats = {
    processed: 0,
    successful: 0,
    failed: 0,
    uniqueBarcodes: new Set(),
    currentCoverage: 0
};

function updateStatistics() {
    // Simulate processing actual sequences
    const batchSize = 100;
    
    for (let i = 0; i < batchSize; i++) {
        stats.processed++;
        
        if (Math.random() < TELHAI_REAL.failureRate) {
            stats.failed++;
        } else {
            stats.successful++;
            const seq = TELHAI_REAL.sequences[Math.floor(Math.random() * TELHAI_REAL.sequences.length)];
            stats.uniqueBarcodes.add(seq.barcode);
        }
    }
    
    // Calculate coverage
    stats.currentCoverage = Math.floor(stats.successful / Math.max(1, stats.uniqueBarcodes.size));
    
    // Update display
    document.getElementById('read-count').textContent = stats.processed.toLocaleString();
    document.getElementById('coverage').textContent = stats.currentCoverage;
    document.getElementById('success').textContent = ((stats.successful / stats.processed * 100) || 0).toFixed(1);
    document.getElementById('unique').textContent = stats.uniqueBarcodes.size;
}

// Audio synthesis for data sonification
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function sonifySequence(sequence) {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    // Map bases to frequencies
    const baseFreq = {
        'A': 220,
        'T': 293.66,
        'G': 329.63,
        'C': 392
    };
    
    oscillator.frequency.value = baseFreq[sequence.barcode[0]] || 440;
    gainNode.gain.value = 0.01;
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.05);
}

// Animation loop
let frame = 0;

function animate() {
    frame++;
    
    // Update helixes
    helixes.forEach(helix => helix.update());
    
    // Update particles
    const positions = particleSystem.geometry.attributes.position.array;
    const colors = particleSystem.geometry.attributes.color.array;
    
    particles.forEach((particle, i) => {
        particle.update();
        
        positions[i * 3] = particle.position.x;
        positions[i * 3 + 1] = particle.position.y;
        positions[i * 3 + 2] = particle.position.z;
        
        // Pulse color
        const pulse = Math.sin(frame * 0.01 + i * 0.1) * 0.5 + 0.5;
        colors[i * 3] = particle.color.r * pulse;
        colors[i * 3 + 1] = particle.color.g * pulse;
        colors[i * 3 + 2] = particle.color.b * pulse;
        
        // Respawn dead particles
        if (particle.life <= 0) {
            particles[i] = new DataParticle(
                TELHAI_REAL.sequences[Math.floor(Math.random() * TELHAI_REAL.sequences.length)]
            );
        }
    });
    
    particleSystem.geometry.attributes.position.needsUpdate = true;
    particleSystem.geometry.attributes.color.needsUpdate = true;
    
    // Camera movement
    camera.position.x = Math.sin(frame * 0.001) * 100;
    camera.position.y = Math.cos(frame * 0.0007) * 50;
    camera.lookAt(0, 0, 0);
    
    // Update statistics
    if (frame % 10 === 0) {
        updateStatistics();
    }
    
    // Sonify occasionally
    if (frame % 60 === 0 && Math.random() < 0.1) {
        const seq = TELHAI_REAL.sequences[Math.floor(Math.random() * TELHAI_REAL.sequences.length)];
        sonifySequence(seq);
    }
    
    // Render
    renderer.render(scene, camera);
    draw2DOverlay();
    
    requestAnimationFrame(animate);
}

// Initialize
async function init() {
    await loadActualData();
    createSequenceRain();
    initializeScene();
    animate();
}

init();

// Mouse interaction
document.addEventListener('mousemove', (e) => {
    const mouseX = (e.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
    
    // Influence particles near mouse
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
    
    particles.forEach(particle => {
        const distance = raycaster.ray.distanceToPoint(particle.position);
        if (distance < 50) {
            particle.velocity.add(
                new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                )
            );
        }
    });
});

// Click to hear data
document.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    
    // Play sequence of actual barcodes
    TELHAI_REAL.sequences.slice(0, 5).forEach((seq, i) => {
        setTimeout(() => sonifySequence(seq), i * 100);
    });
});
</script>

</body>
</html>