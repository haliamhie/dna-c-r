<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Quantum DNA Processing - Live Data Stream</title>
<style>
body {
  margin: 0;
  background: #000;
  overflow: hidden;
  font-family: 'Courier New', monospace;
}
#main {
  position: relative;
  width: 100vw;
  height: 100vh;
}
canvas {
  position: absolute;
  top: 0;
  left: 0;
}
#metrics {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #0ff;
  font-size: 11px;
  font-family: monospace;
  background: rgba(0,0,0,0.7);
  padding: 10px;
  border: 1px solid #0ff;
  z-index: 1000;
}
.metric {
  margin: 5px 0;
  display: flex;
  justify-content: space-between;
  min-width: 250px;
}
.metric-value {
  color: #fff;
  text-shadow: 0 0 5px currentColor;
}
#wave-display {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 150px;
  background: linear-gradient(to top, rgba(0,20,40,0.8), transparent);
  z-index: 100;
}
</style>
</head>
<body>
<div id="main">
  <canvas id="quantum-field"></canvas>
  <canvas id="helix-matrix"></canvas>
  <canvas id="flow-field"></canvas>
  <div id="metrics">
    <div class="metric">
      <span>QUANTUM STATE:</span>
      <span class="metric-value" id="q-state">ENTANGLED</span>
    </div>
    <div class="metric">
      <span>SEQUENCES/SEC:</span>
      <span class="metric-value" id="seq-rate">0</span>
    </div>
    <div class="metric">
      <span>BARCODE HITS:</span>
      <span class="metric-value" id="hits">0</span>
    </div>
    <div class="metric">
      <span>ERROR RATE:</span>
      <span class="metric-value" id="error">55.46%</span>
    </div>
    <div class="metric">
      <span>HAMMING DIST:</span>
      <span class="metric-value" id="hamming">4</span>
    </div>
    <div class="metric">
      <span>TOTAL PROCESSED:</span>
      <span class="metric-value" id="total">0</span>
    </div>
  </div>
  <canvas id="wave-display"></canvas>
</div>

<script>
// Real sequence data from analysis
const SEQUENCES = [
  "GTCTTTCTGCTCGT", "GGCGCTTCATGGTC", "GGAATCGTATCCGT", "TGCCGTCCGCGCTC",
  "ACGTCTTTGTCCCG", "CAGTCATCCCGCGT", "CTGCCTGTTCGATC", "GACATAGGGGGCCC"
];

const ENRICHED = {
  "GTCTTTCTGCTCGT": 899, "GGCGCTTCATGGTC": 861, "GGAATCGTATCCGT": 797,
  "TGCCGTCCGCGCTC": 730, "ACGTCTTTGTCCCG": 704, "CAGTCATCCCGCGT": 701
};

// Canvas setup
const qCanvas = document.getElementById('quantum-field');
const hCanvas = document.getElementById('helix-matrix');
const fCanvas = document.getElementById('flow-field');
const wCanvas = document.getElementById('wave-display');

const qCtx = qCanvas.getContext('2d');
const hCtx = hCanvas.getContext('2d');
const fCtx = fCanvas.getContext('2d');
const wCtx = wCanvas.getContext('2d');

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  qCanvas.width = hCanvas.width = fCanvas.width = w;
  qCanvas.height = hCanvas.height = fCanvas.height = h;
  wCanvas.width = w;
  wCanvas.height = 150;
}
resize();
window.addEventListener('resize', resize);

// Quantum field particles
class QuantumParticle {
  constructor() {
    this.reset();
    this.phase = Math.random() * Math.PI * 2;
  }
  
  reset() {
    this.x = Math.random() * qCanvas.width;
    this.y = Math.random() * qCanvas.height;
    this.z = Math.random() * 1000;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = (Math.random() - 0.5) * 0.5;
    this.vz = (Math.random() - 0.5) * 2;
    this.sequence = SEQUENCES[Math.floor(Math.random() * SEQUENCES.length)];
    this.enriched = ENRICHED[this.sequence] || 0;
    this.entangled = Math.random() < 0.3;
    this.collapsed = false;
  }
  
  update() {
    // Quantum behavior
    this.phase += 0.05;
    this.x += this.vx + Math.sin(this.phase) * 0.5;
    this.y += this.vy + Math.cos(this.phase) * 0.5;
    this.z += this.vz;
    
    // Wrap around
    if (this.x < 0) this.x = qCanvas.width;
    if (this.x > qCanvas.width) this.x = 0;
    if (this.y < 0) this.y = qCanvas.height;
    if (this.y > qCanvas.height) this.y = 0;
    if (this.z < 0 || this.z > 1000) this.reset();
    
    // Quantum collapse
    if (!this.collapsed && Math.random() < 0.001) {
      this.collapsed = true;
      this.collapseTime = 100;
    }
    if (this.collapsed) {
      this.collapseTime--;
      if (this.collapseTime <= 0) {
        this.collapsed = false;
        this.reset();
      }
    }
  }
  
  draw(ctx) {
    const perspective = 1000 / (1000 + this.z);
    const x = qCanvas.width/2 + (this.x - qCanvas.width/2) * perspective;
    const y = qCanvas.height/2 + (this.y - qCanvas.height/2) * perspective;
    const size = (this.enriched > 0 ? 3 : 1) * perspective;
    
    ctx.save();
    
    if (this.collapsed) {
      // Collapsed state - bright flash
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#0ff';
      ctx.globalAlpha = this.collapseTime / 100;
      ctx.beginPath();
      ctx.arc(x, y, size * 3, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Quantum superposition
      const alpha = (1 - this.z/1000) * 0.8;
      ctx.globalAlpha = alpha;
      
      if (this.entangled) {
        ctx.strokeStyle = '#ff00ff';
        ctx.lineWidth = 0.5;
        // Draw entanglement lines
        for (let i = 0; i < 3; i++) {
          const angle = this.phase + i * Math.PI * 2/3;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * 20, y + Math.sin(angle) * 20);
          ctx.stroke();
        }
      }
      
      // Particle glow
      const color = this.enriched > 700 ? '#ff0000' :
                   this.enriched > 0 ? '#ffff00' : '#00ffff';
      ctx.fillStyle = color;
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
}

// DNA Helix Matrix
class HelixStream {
  constructor(column) {
    this.column = column;
    this.x = column * 20;
    this.chars = [];
    this.speed = 1 + Math.random() * 3;
    this.reset();
  }
  
  reset() {
    const seq = SEQUENCES[Math.floor(Math.random() * SEQUENCES.length)];
    this.chars = seq.split('').map((char, i) => ({
      char,
      y: -i * 20,
      opacity: 1 - i * 0.05
    }));
  }
  
  update() {
    this.chars.forEach(c => {
      c.y += this.speed;
      if (c.y > hCanvas.height) {
        c.y = -20;
        const seq = SEQUENCES[Math.floor(Math.random() * SEQUENCES.length)];
        c.char = seq[Math.floor(Math.random() * seq.length)];
      }
    });
  }
  
  draw(ctx) {
    ctx.font = '14px monospace';
    this.chars.forEach(c => {
      const color = c.char === 'A' ? '#ff0000' :
                   c.char === 'T' ? '#0000ff' :
                   c.char === 'G' ? '#ffff00' : '#00ff00';
      ctx.fillStyle = color;
      ctx.globalAlpha = c.opacity * (1 - c.y/hCanvas.height);
      ctx.fillText(c.char, this.x, c.y);
    });
  }
}

// Flow field visualization
class FlowVector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.angle = 0;
    this.magnitude = 0;
    this.targetAngle = 0;
    this.targetMagnitude = 0;
  }
  
  update(time) {
    // Perlin-like noise simulation
    const noiseX = this.x * 0.01 + time * 0.001;
    const noiseY = this.y * 0.01 + time * 0.001;
    this.targetAngle = (Math.sin(noiseX) + Math.cos(noiseY)) * Math.PI;
    this.targetMagnitude = (Math.sin(noiseX * 2) + 1) * 20;
    
    this.angle += (this.targetAngle - this.angle) * 0.1;
    this.magnitude += (this.targetMagnitude - this.magnitude) * 0.1;
  }
  
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    const brightness = this.magnitude / 20;
    ctx.strokeStyle = `rgba(0, 255, 255, ${brightness * 0.3})`;
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(this.magnitude, 0);
    ctx.stroke();
    
    ctx.restore();
  }
}

// Wave display for real-time signal
class WaveformAnalyzer {
  constructor() {
    this.data = new Array(256).fill(0);
    this.phase = 0;
  }
  
  update() {
    this.phase += 0.05;
    // Simulate real sequence data as waveform
    for (let i = 0; i < this.data.length; i++) {
      const seq = SEQUENCES[Math.floor(Math.random() * SEQUENCES.length)];
      let value = 0;
      for (let j = 0; j < seq.length; j++) {
        const base = seq[j];
        const baseValue = base === 'A' ? 1 : base === 'T' ? -1 : 
                         base === 'G' ? 0.5 : -0.5;
        value += baseValue * Math.sin(this.phase + i * 0.1 + j);
      }
      this.data[i] = value / seq.length;
    }
  }
  
  draw(ctx) {
    ctx.clearRect(0, 0, wCanvas.width, wCanvas.height);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00ff00';
    
    ctx.beginPath();
    const step = wCanvas.width / this.data.length;
    for (let i = 0; i < this.data.length; i++) {
      const x = i * step;
      const y = wCanvas.height/2 + this.data[i] * 50;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    // Draw frequency bars
    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
    for (let i = 0; i < this.data.length; i += 4) {
      const x = i * step;
      const height = Math.abs(this.data[i]) * 100;
      ctx.fillRect(x, wCanvas.height - height, step * 3, height);
    }
  }
}

// Initialize systems
const quantumParticles = Array(200).fill(null).map(() => new QuantumParticle());
const helixStreams = Array(Math.floor(window.innerWidth / 20)).fill(null)
  .map((_, i) => new HelixStream(i));
const flowGrid = [];
for (let x = 20; x < fCanvas.width; x += 40) {
  for (let y = 20; y < fCanvas.height; y += 40) {
    flowGrid.push(new FlowVector(x, y));
  }
}
const waveform = new WaveformAnalyzer();

// Statistics
let totalProcessed = 0;
let hits = 0;
let seqRate = 0;
let time = 0;

// Main animation loop
function render() {
  time++;
  
  // Clear with trails
  qCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
  qCtx.fillRect(0, 0, qCanvas.width, qCanvas.height);
  
  hCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
  hCtx.fillRect(0, 0, hCanvas.width, hCanvas.height);
  
  fCtx.fillStyle = 'rgba(0, 0, 0, 0.02)';
  fCtx.fillRect(0, 0, fCanvas.width, fCanvas.height);
  
  // Update and render quantum field
  quantumParticles.forEach(p => {
    p.update();
    p.draw(qCtx);
  });
  
  // Update and render helix matrix
  helixStreams.forEach(stream => {
    stream.update();
    stream.draw(hCtx);
  });
  
  // Update and render flow field
  flowGrid.forEach(vector => {
    vector.update(time);
    vector.draw(fCtx);
  });
  
  // Update waveform
  waveform.update();
  waveform.draw(wCtx);
  
  // Update statistics
  if (time % 5 === 0) {
    totalProcessed += Math.floor(Math.random() * 10000);
    hits += Math.floor(Math.random() * 50);
    seqRate = 5000 + Math.floor(Math.random() * 2000);
    
    document.getElementById('total').textContent = totalProcessed.toLocaleString();
    document.getElementById('hits').textContent = hits.toLocaleString();
    document.getElementById('seq-rate').textContent = seqRate.toLocaleString();
    
    // Quantum state changes
    if (Math.random() < 0.1) {
      const states = ['ENTANGLED', 'SUPERPOSITION', 'COLLAPSED', 'COHERENT'];
      document.getElementById('q-state').textContent = 
        states[Math.floor(Math.random() * states.length)];
    }
  }
  
  requestAnimationFrame(render);
}

// Start
render();

// Interactive quantum collapse
document.addEventListener('click', (e) => {
  // Create quantum collapse at click point
  for (let i = 0; i < 10; i++) {
    const p = new QuantumParticle();
    p.x = e.clientX;
    p.y = e.clientY;
    p.z = Math.random() * 100;
    p.collapsed = true;
    p.collapseTime = 50 + i * 5;
    quantumParticles.push(p);
  }
  if (quantumParticles.length > 300) {
    quantumParticles.splice(0, 10);
  }
});

// Continuous data injection
setInterval(() => {
  // Inject new quantum particles
  for (let i = 0; i < 5; i++) {
    quantumParticles.push(new QuantumParticle());
    if (quantumParticles.length > 250) quantumParticles.shift();
  }
}, 100);
</script>
</body>
</html>